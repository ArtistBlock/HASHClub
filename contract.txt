// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

interface IEditionStake {
    function getStakeInfo(address _staker) external view returns (
        uint256[] memory,
        uint256[] memory,
        uint256 _totalRewards
    );
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract HashAchievementNFTs {
    string public constant name = "Mining Hash Club";
    string public constant symbol = "CLUB";

    address public constant STAKING_CONTRACT = 0xBBc4f75874930EB4d8075FCB3f48af2535A8E848;
    uint256 public constant TRANSFER_UNLOCK_TIME = 1891572042; 

    // ğŸ¯ Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ñ€Ğ¾Ğ³Ğ¸ (Ğ² wei Ğ´Ğ»Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚Ğ¸)
    uint256 public constant DOLPHIN_HASH = 1000 ether;  // 1,000 HASH
    uint256 public constant SHARK_HASH = 5000 ether;    // 5,000 HASH  
    uint256 public constant WHALE_HASH = 25000 ether;   // 25,000 HASH

    string private constant DOLPHIN_URI = "https://bafkreibslmgaovzo24fpa3nulmaak3qfiwcfbba4uhcxx4m5me3aeypxd4.ipfs.dweb.link/";
    string private constant SHARK_URI   = "https://bafkreib4kaiiqkbisq3lt7gxtwph7yovynobsxcbtnubdwcafccz2wdekm.ipfs.dweb.link/";
    string private constant WHALE_URI   = "https://bafkreif2mmnb37tf33fso4ruz6spzzbxjjptznghfkqk7aam3fqusvvtgy.ipfs.dweb.link/";

    enum Tier { None, Dolphin, Shark, Whale }
    
    // ğŸ¯ Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ¾Ğµ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(Tier => bool)) public hasTier;
    mapping(uint256 => Tier) private _tokenTier;

    uint256 private _tokenIdCounter = 1;
    uint256 public dolphinCount;
    uint256 public sharkCount;
    uint256 public whaleCount;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event TierMinted(address indexed user, Tier tier, uint256 tokenId);

    // ğŸ¯ ĞĞ¡ĞĞĞ’ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ Ğ”Ğ›Ğ¯ Ğ˜ĞĞ¢Ğ•Ğ Ğ¤Ğ•Ğ™Ğ¡Ğ

    /**
     * @dev ĞœĞ¸Ğ½Ñ‚ NFT Ğ´ĞµĞ»ÑŒÑ„Ğ¸Ğ½Ğ° - Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
     */
    function mintDolphin() external { 
        _mintTier(Tier.Dolphin, DOLPHIN_HASH); 
    }
    
    function mintShark() external { 
        _mintTier(Tier.Shark, SHARK_HASH); 
    }
    
    function mintWhale() external { 
        _mintTier(Tier.Whale, WHALE_HASH); 
    }

    /**
     * @dev Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¼Ğ¸Ğ½Ñ‚Ğ°
     */
    function _mintTier(Tier tier, uint256 threshold) internal {
        require(!hasTier[msg.sender][tier], "Already minted");
        
        // ğŸ¯ ĞŸÑ€ÑĞ¼Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° staking ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°
        uint256 userRewards = _getUserRewards(msg.sender);
        require(userRewards >= threshold, "Not enough HASH");
        
        hasTier[msg.sender][tier] = true;
        uint256 tokenId = _tokenIdCounter++;

        _owners[tokenId] = msg.sender;
        _balances[msg.sender]++;
        _tokenTier[tokenId] = tier;

        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ¸
        if (tier == Tier.Dolphin) dolphinCount++;
        else if (tier == Tier.Shark) sharkCount++;
        else if (tier == Tier.Whale) whaleCount++;

        emit Transfer(address(0), msg.sender, tokenId);
        emit TierMinted(msg.sender, tier, tokenId);
    }

    /**
     * @dev ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
     */
    function _getUserRewards(address user) internal view returns (uint256) {
        (, , uint256 totalRewards) = IEditionStake(STAKING_CONTRACT).getStakeInfo(user);
        return totalRewards;
    }

    // ğŸ¯ Ğ£ĞŸĞ ĞĞ©Ğ•ĞĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ Ğ”Ğ›Ğ¯ Ğ˜ĞĞ¢Ğ•Ğ Ğ¤Ğ•Ğ™Ğ¡Ğ

    /**
     * @dev ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ° - Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ’Ğ¡Ğ• Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
     */
    function getUserStatus(address user) external view returns (
        uint256 earnedHASH,      // Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ½Ğ°Ğ¼Ğ°Ğ¹Ğ½Ğ¸Ğ»
        bool dolphinAvailable,   // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ¼Ğ¸Ğ½Ñ‚Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ»ÑŒÑ„Ğ¸Ğ½Ğ°
        bool sharkAvailable,     // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ¼Ğ¸Ğ½Ñ‚Ğ¸Ñ‚ÑŒ Ğ°ĞºÑƒĞ»Ñƒ
        bool whaleAvailable,     // ĞœĞ¾Ğ¶ĞµÑ‚ Ğ¼Ğ¸Ğ½Ñ‚Ğ¸Ñ‚ÑŒ ĞºĞ¸Ñ‚Ğ°
        bool hasDolphinNFT,      // Ğ£Ğ¶Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ´ĞµĞ»ÑŒÑ„Ğ¸Ğ½Ğ°
        bool hasSharkNFT,        // Ğ£Ğ¶Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ°ĞºÑƒĞ»Ñƒ
        bool hasWhaleNFT         // Ğ£Ğ¶Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ ĞºĞ¸Ñ‚Ğ°
    ) {
        earnedHASH = _getUserRewards(user);
        
        dolphinAvailable = earnedHASH >= DOLPHIN_HASH && !hasTier[user][Tier.Dolphin];
        sharkAvailable = earnedHASH >= SHARK_HASH && !hasTier[user][Tier.Shark];
        whaleAvailable = earnedHASH >= WHALE_HASH && !hasTier[user][Tier.Whale];
        
        hasDolphinNFT = hasTier[user][Tier.Dolphin];
        hasSharkNFT = hasTier[user][Tier.Shark];
        hasWhaleNFT = hasTier[user][Tier.Whale];
    }

    /**
     * @dev Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ-Ğ±Ğ°Ñ€Ğ°
     */
    function getQuickStats(address user) external view returns (
        uint256 earnedHASH,
        string memory availableTiers
    ) {
        earnedHASH = _getUserRewards(user);
        
        if (earnedHASH >= WHALE_HASH) availableTiers = "WHALE_READY";
        else if (earnedHASH >= SHARK_HASH) availableTiers = "SHARK_READY";
        else if (earnedHASH >= DOLPHIN_HASH) availableTiers = "DOLPHIN_READY";
        else availableTiers = "MINING";
    }

    /**
     * @dev ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ñ€Ğ°
     */
    function canMintTier(address user, Tier tier) external view returns (bool) {
        uint256 earnedHASH = _getUserRewards(user);
        
        if (tier == Tier.Dolphin) return earnedHASH >= DOLPHIN_HASH && !hasTier[user][Tier.Dolphin];
        if (tier == Tier.Shark) return earnedHASH >= SHARK_HASH && !hasTier[user][Tier.Shark];
        if (tier == Tier.Whale) return earnedHASH >= WHALE_HASH && !hasTier[user][Tier.Whale];
        return false;
    }

    // ğŸ¯ ĞĞ¡ĞĞĞ’ĞĞ«Ğ• ERC-721 Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜

    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), "Invalid address");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "NFT doesn't exist");
        return owner;
    }

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_owners[tokenId] != address(0), "NFT doesn't exist");
        Tier t = _tokenTier[tokenId];
        if (t == Tier.Dolphin) return DOLPHIN_URI;
        if (t == Tier.Shark) return SHARK_URI;
        if (t == Tier.Whale) return WHALE_URI;
        revert("Invalid tier");
    }

    // ğŸ¯ Ğ‘Ğ•Ğ—ĞĞŸĞĞ¡ĞĞ«Ğ• Ğ¢Ğ ĞĞĞ¡Ğ¤Ğ•Ğ Ğ« (Soulbound Ğ´Ğ¾ 2029)

    function approve(address, uint256) public pure {
        revert("Soulbound until 2029");
    }

    function setApprovalForAll(address, bool) public pure {
        revert("Soulbound until 2029");
    }

    function transferFrom(address, address, uint256) public pure {
        revert("Soulbound until 2029");
    }

    function safeTransferFrom(address, address, uint256) public pure {
        revert("Soulbound until 2029");
    }

    function safeTransferFrom(address, address, uint256, bytes memory) public pure {
        revert("Soulbound until 2029");
    }

    function _checkTransferLock() internal view {
        require(block.timestamp >= TRANSFER_UNLOCK_TIME, "Soulbound until 2029");
    }
}


// ğŸ“± ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ React ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚
export function AchievementButtons({ wallet }) {
  const ownerAddress = wallet.getAccount()?.address;

  // ğŸ¯ ĞĞ´Ğ¸Ğ½ Ğ²Ñ‹Ğ·Ğ¾Ğ² - Ğ²ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
  const { data: userStatus, refetch } = useReadContract({
    contract: whaleContract,
    method: "getUserStatus",
    params: [ownerAddress || ""],
  });

  // ğŸ“Š Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
  const [earnedHASH, dolphinAvailable, sharkAvailable, whaleAvailable, hasDolphin, hasShark, hasWhale] = userStatus || [];

  // ğŸ¯ Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¼Ğ¸Ğ½Ñ‚Ğ°
  const { mutate: mintDolphin } = useSendAndConfirmTransaction();
  const { mutate: mintShark } = useSendAndConfirmTransaction();
  const { mutate: mintWhale } = useSendAndConfirmTransaction();

  return (
    <div className="achievements">
      {/* ğŸ¬ Ğ”ĞµĞ»ÑŒÑ„Ğ¸Ğ½ */}
      <button
        onClick={() => mintDolphin(prepareContractCall(whaleContract, "mintDolphin")).then(refetch)}
        disabled={!dolphinAvailable || hasDolphin}
        className={dolphinAvailable ? "ready" : "locked"}
      >
        {hasDolphin ? "âœ… Dolphin" : 
         dolphinAvailable ? "ğŸ¯ Claim Dolphin" : 
         `ğŸ¬ ${Number(earnedHASH/1e18)}/1000 HASH`}
      </button>

      {/* ğŸ¦ˆ ĞĞºÑƒĞ»Ğ° */}
      <button
        onClick={() => mintShark(prepareContractCall(whaleContract, "mintShark")).then(refetch)}
        disabled={!sharkAvailable || hasShark}
        className={sharkAvailable ? "ready" : "locked"}
      >
        {hasShark ? "âœ… Shark" : 
         sharkAvailable ? "ğŸ¯ Claim Shark" : 
         `ğŸ¦ˆ ${Number(earnedHASH/1e18)}/5000 HASH`}
      </button>

      {/* ğŸ‹ ĞšĞ¸Ñ‚ */}
      <button
        onClick={() => mintWhale(prepareContractCall(whaleContract, "mintWhale")).then(refetch)}
        disabled={!whaleAvailable || hasWhale}
        className={whaleAvailable ? "ready" : "locked"}
      >
        {hasWhale ? "âœ… Whale" : 
         whaleAvailable ? "ğŸ¯ Claim Whale" : 
         `ğŸ‹ ${Number(earnedHASH/1e18)}/25000 HASH`}
      </button>
    </div>
  );
}